// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3550.Robotronix2017.subsystems;

import org.usfirst.frc3550.Robotronix2017.RobotMap;
import org.usfirst.frc3550.Robotronix2017.commands.*;
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DeplacementSubsystem extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	
	public static final double NORMALSPEED  = 0.90;  //drive for normal speed
	public static final double SLOWSPEED    = 0.75;  //drive motor slow speed
	public static final boolean SENSITIVITY = true; // drive motor sensibility

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
    private final CANTalon leftFrontMotor = RobotMap.deplacementleftFrontMotor;
    private final CANTalon rightFrontMotor = RobotMap.deplacementrightFrontMotor;
    private final CANTalon leftRearMotor = RobotMap.deplacementleftRearMotor;
    private final CANTalon rightRearMotor = RobotMap.deplacementrightRearMotor;
    private final RobotDrive robotDrive41 = RobotMap.deplacementRobotDrive41;
   // private final VictorSP motorTest = RobotMap.motorTest;
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    	
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
         setDefaultCommand(new deplacementJoystick());
    }
    
    /**
	 * stop method is used to stop the robot 
	 * 
	 * @param no input parameter
	 */
	public void stop() {
		robotDrive41.drive(0, 0);
	}
	
	private void inverseMotors(boolean inverse) {
		leftFrontMotor.setInverted(inverse);
		leftRearMotor.setInverted(inverse);
		rightFrontMotor.setInverted(inverse);
		rightRearMotor.setInverted(inverse);
		//motorTest.setInverted(inverse);
	}
	
	/**
	 * driveStraight method is used in autonomous mode to let the robot goes straight
	 * 
	 * @param speed The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 */
	public void driveStraight(double speed) {
		// Configure the RobotDrive to reflect the fact that all our motors are
	    // wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.drive(speed, 0);
	}
	
	/**
	 * drive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void drive(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue, NORMALSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDrive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability.
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void inverseDrive(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue,NORMALSPEED* -1 * rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * It provides the pilot with the ability to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */
	public void driveSlow(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDriveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */	
	public void inverseDriveSlow(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, -1*SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void driveTank(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		//m_drive.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
		robotDrive41.tankDrive(NORMALSPEED*leftStick, NORMALSPEED*rightStick, SENSITIVITY);
	}
	
	/**
	 * inversedriveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void inverseTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.tankDrive(NORMALSPEED*rightStick, NORMALSPEED*leftStick, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void SlowTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		//m_drive.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
		robotDrive41.tankDrive(leftStick*SLOWSPEED, rightStick*SLOWSPEED, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void inverseSlowTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.tankDrive(rightStick*SLOWSPEED, leftStick*SLOWSPEED, SENSITIVITY);
	}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}

