// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3550.Robotronix2017.subsystems;

import org.usfirst.frc3550.Robotronix2017.Robot;
import org.usfirst.frc3550.Robotronix2017.RobotMap;
import org.usfirst.frc3550.Robotronix2017.commands.*;
import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class BaseMobileSubsystem extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	
	public static final double NORMALSPEED  = 0.95;  //drive for normal speed
	public static final double SLOWSPEED    = 0.50;  //drive motor slow speed
	public static final boolean SENSITIVITY = true; // drive motor sensibility

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
    private final CANTalon leftFrontMotor = RobotMap.deplacementleftFrontMotor;
    private final CANTalon rightFrontMotor = RobotMap.deplacementrightFrontMotor;
    private final CANTalon leftRearMotor = RobotMap.deplacementleftRearMotor;
    private final CANTalon rightRearMotor = RobotMap.deplacementrightRearMotor;
    private final RobotDrive robotDrive41 = RobotMap.deplacementRobotDrive41;
    private final AnalogGyro     gyro         = RobotMap.gyro;
  //  private final Encoder      encoder      =  RobotMap.deplacementleftRearMotor.getPIDSourceType();
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  //  Robot.deplacement.getLeftRearMotor().setControlMode(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
	
    // Put methods for controlling this subsystem
    // . Call these from Commands.
    
   // public BaseMobileSubsystem(){
   // 	super();
    	
  //  }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    	
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
         setDefaultCommand(new DriveWithJoystickCommand());
    }
    
    public double getGyroAngle(){
    	return gyro.getAngle();
    }
    
    public void clearGyroAngle(){
    	 gyro.reset();
    }
    
    public CANTalon getLeftFrontMotor(){
    	return leftFrontMotor;
    }
    
    public CANTalon getRightFrontMotor(){
    	return rightFrontMotor;
    }
    
    public CANTalon getLeftRearMotor(){
    	return leftRearMotor;
    }
    
    public CANTalon getRightRearMotor(){
    	return rightRearMotor;
    }
    
    public double getPositionLeftRearMotor(){
    	//return (-1)*Robot.deplacement.getLeftRearMotor().getPosition(); 
    	return (-1)*getLeftRearMotor().getPosition(); 
    }
    
    public void clearLeftRearEncoder(){
    	Robot.deplacement.getLeftRearMotor().setPosition(0);
    	//Robot.deplacement.getLeftRearMotor().reset();
    	//Robot.deplacement.getLeftRearMotor().ClearIaccum();;
    }
    
    public double getSpeedLeftRearMotor(){
    	return getLeftRearMotor().getSpeed();
    }
    
    public void setLeftRearMotorEncoderMode(){
    	 getLeftRearMotor().setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
    }
    /**
	 * stop method is used to stop the robot 
	 * 
	 * @param no input parameter
	 */
	public void stopBaseMobile() {
		robotDrive41.drive(0, 0);
	}
	
	public void display(){
	 SmartDashboard.putNumber("speedDeplacmentLeftFront", leftFrontMotor.get());
	 SmartDashboard.putNumber("speedDeplacmentLeftRear",leftRearMotor.get());
	 SmartDashboard.putNumber("speedDeplacmentRightFront", rightFrontMotor.get());
	 SmartDashboard.putNumber("speedDeplacmentRightRear",rightRearMotor.get());
	 SmartDashboard.putNumber("EncoderPosition", getPositionLeftRearMotor());
	}

	private void inverseMotors(boolean inverse) {
		leftFrontMotor.setInverted(inverse);
		leftRearMotor.setInverted(inverse);
		rightFrontMotor.setInverted(inverse);
		rightRearMotor.setInverted(inverse);
		//motorTest.setInverted(inverse);
	}
	
	/**
	 * driveStraight method is used in autonomous mode to let the robot goes straight
	 * 
	 * @param speed The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 */
	public void driveStraight(double speed) {
		// Configure the RobotDrive to reflect the fact that all our motors are
	    // wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.drive(speed, 0);
	}
	
	/**
	 * drive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void drive(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue, NORMALSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDrive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability.
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void inverseDrive(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue,NORMALSPEED* -1 * rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * It provides the pilot with the ability to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */
	public void driveSlow(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDriveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */	
	public void inverseDriveSlow(double moveValue, double rotateValue) {
		//double moveValue = Robot.oi.getgamePadPiloteY();
		//double rotateValue = Robot.oi.getgamePadPiloteX();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, -1*SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void driveTank(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		//m_drive.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
		robotDrive41.tankDrive(NORMALSPEED*leftStick, NORMALSPEED*rightStick, SENSITIVITY);
	}
	
	/**
	 * inversedriveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void inverseTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.tankDrive(NORMALSPEED*rightStick, NORMALSPEED*leftStick, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void SlowTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(true);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(true);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(true);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(true);
		inverseMotors(true);
		//m_drive.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
		robotDrive41.tankDrive(leftStick*SLOWSPEED, rightStick*SLOWSPEED, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void inverseSlowTankDrive(double leftStick, double rightStick) {
		//leftStick = Robot.oi.getgamePadPiloteYLeft();
		//rightStick = Robot.oi.getgamePadPiloteYRight();
		
		// Configure the RobotDrive to reflect the fact that all our motors are
		// wired backwards and our drivers sensitivity preferences.
//		RobotMap.moteurDeplacementAvantGauche.setInverted(false);
//		RobotMap.moteurDeplacementArriereGauche.setInverted(false);
//		RobotMap.moteurDeplacementAvantDroite.setInverted(false);
//		RobotMap.moteurDeplacementArriereDroite.setInverted(false);
		inverseMotors(false);
		robotDrive41.tankDrive(rightStick*SLOWSPEED, leftStick*SLOWSPEED, SENSITIVITY);
	}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}

